static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom) AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 )  st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ]; sc = st -> priv_data; entries = avio_rb32 ( pb ); if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) )  sc -> drefs_count = 0; sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ); if ( ! sc -> drefs )  sc -> drefs_count = entries; for (i = 0; i < sc->drefs_count; i++) MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 )  dref -> type = avio_rl32 ( pb ); if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 )  uint16_t volume_len , len ; int16_t type ; volume_len = avio_r8 ( pb ); volume_len = FFMIN ( volume_len , 27 ); for (type = 0; type != -1 && avio_tell(pb) < next; ) if ( url_feof ( pb ) )  type = avio_rb16 ( pb ); len = avio_rb16 ( pb ); if ( len & 1 )  len += 1; if ( type == 2 )  dref -> path = av_mallocz ( len + 1 ); if ( ! dref -> path )  if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) )  len -= volume_len; memmove ( dref -> path , dref -> path + volume_len , len ); dref -> path [ len ] = 0; for (j = 0; j < len; j++) if ( dref -> path [ j ] == ':' )  dref -> path [ j ] = '/'; av_log ( c -> fc , AV_LOG_DEBUG , "path %s\n" , dref -> path ); if ( type == 0 )  dref -> dir = av_malloc ( len + 1 ); if ( ! dref -> dir )  if ( dref -> dir [ j ] == ':' )  