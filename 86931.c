proto_tree ptvcursor_add_with_subtree(ptvcursor_t *ptvc, int hfindex, gint const guint encoding, gint ett_subtree) proto_item * it ; it = ptvcursor_add_no_advance ( ptvc , hfindex , length , encoding ); proto_item ptvcursor_add_no_advance(ptvcursor_t* ptvc, int hf, gint const guint encoding) proto_item * item ; item = proto_tree_add_item ( ptvc -> tree , hf , ptvc -> tvb , ptvc -> offset , length , encoding ); proto_item proto_tree_add_item(proto_tree *tree, int hfindex, tvbuff_t const gint start, gint length, const guint encoding) register header_field_info * hfinfo ; return proto_tree_add_item_new ( tree , hfinfo , tvb , start , length , encoding ) ; proto_item proto_tree_add_item_new(proto_tree *tree, header_field_info *hfinfo, tvbuff_t const gint start, gint length, const guint encoding) field_info * new_fi ; gint item_length ; new_fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); static field_info new_field_info(proto_tree *tree, header_field_info *hfinfo, tvbuff_t const gint start, const gint item_length) field_info * fi ; fi -> hfinfo = hfinfo; fi -> start = start; fi -> start += ( tvb ) ? tvb_raw_offset ( tvb ) : 0; fi -> length = item_length; fi -> tree_type = - 1; fi -> flags = 0; fi -> rep = NULL; fi -> ds_tvb = tvb ? tvb_get_ds_tvb ( tvb ) : NULL; fi -> appendix_start = 0; fi -> appendix_length = 0; return fi ; if ( new_fi == NULL )  return NULL ; return proto_tree_new_item ( new_fi , tree , tvb , start , length , encoding ) ; static proto_item proto_tree_new_item(field_info *new_fi, proto_tree tvbuff_t *tvb, gint start, gint guint encoding) proto_item * pi ; guint32 value , n ; switch ( new_fi -> hfinfo -> type )  if ( encoding )  encoding = ENC_LITTLE_ENDIAN; n = get_uint_value ( tree , tvb , start , length , encoding ); static get_uint_value(proto_tree *tree, tvbuff_t *tvb, gint offset, gint length, const guint encoding) guint32 value ; switch ( length )  value = tvb_get_guint8 ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohs ( tvb , offset ) : tvb_get_ntohs ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letoh24 ( tvb , offset ) : tvb_get_ntoh24 ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ); if ( length < 1 )  value = 0; value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ); return value ; new_fi -> length = n + length; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding )  encoding = ENC_LITTLE_ENDIAN; if ( encoding == TRUE )  encoding = ENC_LITTLE_ENDIAN; new_fi -> length = length; if ( encoding == TRUE )  encoding = ENC_ASCII | ENC_LITTLE_ENDIAN; n = get_uint_value ( tree , tvb , start , length , encoding & ~ENC_CHARENCODING_MASK ); static get_uint_value(proto_tree *tree, tvbuff_t *tvb, gint offset, gint length, const guint encoding) guint32 value ; switch ( length )  value = tvb_get_guint8 ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohs ( tvb , offset ) : tvb_get_ntohs ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letoh24 ( tvb , offset ) : tvb_get_ntoh24 ( tvb , offset ); value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ); if ( length < 1 )  value = 0; value = ( encoding & ENC_LITTLE_ENDIAN ) ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ); return value ; new_fi -> length = n + length; pi = proto_tree_add_node ( tree , new_fi ); static proto_item proto_tree_add_node(proto_tree *tree, field_info *fi) proto_node * pnode , * tnode , * sibling ; tnode = tree; pnode = wmem_new ( PNODE_POOL ( tree ) , proto_node ); pnode -> parent = tnode; pnode -> tree_data = PTREE_DATA ( tree ); return ( proto_item * ) pnode ; return pi ; return item ; return ptvcursor_add_subtree_item ( ptvc , it , ett_subtree , length ) ; static proto_tree ptvcursor_add_subtree_item(ptvcursor_t *ptvc, proto_item *it, gint ett_subtree, gint length) ptvcursor_push_subtree ( ptvc , it , ett_subtree ); proto_tree ptvcursor_push_subtree(ptvcursor_t *ptvc, proto_item *it, gint ett_subtree) if ( ptvc -> pushed_tree_index >= ptvc -> pushed_tree_max )  ptvcursor_new_subtree_levels ( ptvc ); static ptvcursor_new_subtree_levels(ptvcursor_t *ptvc) subtree_lvl * pushed_tree ; ptvc -> pushed_tree_max += SUBTREE_ONCE_ALLOCATION_NUMBER; pushed_tree = ( subtree_lvl * ) wmem_alloc ( wmem_packet_scope ( ) , sizeof ( subtree_lvl ) * ptvc -> pushed_tree_max ); if ( ptvc -> pushed_tree )  memcpy ( pushed_tree , ptvc -> pushed_tree , ptvc -> pushed_tree_max - SUBTREE_ONCE_ALLOCATION_NUMBER ); ptvc -> pushed_tree = pushed_tree; 