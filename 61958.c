static int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl) struct inode * inode = file_inode ( file ) ; struct fuse_conn * fc = get_fuse_conn ( inode ) ; int err ; if ( cmd == F_CANCELLK )  if ( cmd == F_GETLK )  if ( fc -> no_lock )  err = fuse_setlk ( file , fl , 0 ); static int fuse_setlk(struct file *file, struct file_lock *fl, int flock) struct fuse_lk_in inarg ; int opcode = ( fl -> fl_flags & FL_SLEEP ) ? FUSE_SETLKW : FUSE_SETLK ; pid_t pid = fl -> fl_type != F_UNLCK ? current -> tgid : 0 ; if ( fl -> fl_lmops && fl -> fl_lmops -> lm_grant )  if ( fl -> fl_flags & FL_CLOSE )  fuse_lk_fill ( & args , file , fl , opcode , pid , flock , & inarg ); static void fuse_lk_fill(struct fuse_args *args, struct file const struct file_lock *fl, int opcode, pid_t int flock, struct fuse_lk_in *inarg) memset ( inarg , 0 , sizeof ( * inarg ) ); inarg -> fh = ff -> fh; inarg -> owner = fuse_lock_owner_id ( fc , fl -> fl_owner ); inarg -> lk . start = fl -> fl_start; inarg -> lk . end = fl -> fl_end; inarg -> lk . type = fl -> fl_type; inarg -> lk . pid = pid; inarg -> lk_flags |= FUSE_LK_FLOCK; args -> in . args [ 0 ] . size = sizeof ( * inarg ); args -> in . args [ 0 ] . value = inarg; 