static gboolean vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) vwr_t * vwr = ( vwr_t * ) wth -> priv ; guint8 rec [ B_SIZE ] ; int rec_size = 0 , IS_TX ; guint8 * data_ptr ; if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )  static gboolean vwr_read_rec_header(vwr_t *vwr, FILE_T fh, int *rec_size, int *IS_TX, int *err, gchar **err_info) int bytes_read , file_off ; int f_len , v_type ; guint8 header [ 16 ] ; while ( 1 )  if ( ( bytes_read = file_read ( header , 16 , fh ) ) != 16 )  return ( FALSE ) ; if ( ( f_len = decode_msg ( vwr , header , & v_type , IS_TX ) ) != 0 )  static int decode_msg(vwr_t *vwr, guint8 *rec, int *v_type, int *IS_TX) guint8 cmd ; guint32 wd2 , wd3 ; int v_size = 0 ; cmd = rec [ 0 ]; wd2 = pntohl ( & rec [ 8 ] ); wd3 = pntohl ( & rec [ 12 ] ); switch ( cmd )  v_size = ( int ) ( wd2 & 0xffff ); v_size = ( int ) ( wd2 & 0xffff ); v_size = ( int ) ( wd3 & 0xffff ); return ( v_size ) ; if ( f_len > B_SIZE )  return ( FALSE ) ; if ( v_type != VT_FRAME )  if ( file_seek ( fh , f_len , SEEK_CUR , err ) < 0 )  return ( FALSE ) ; return ( TRUE ) ; if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )  data_ptr = buffer_start_ptr ( wth -> frame_buffer ); switch ( vwr -> FPGA_VERSION )  vwr_read_rec_data ( wth , data_ptr , rec , rec_size ); static void vwr_read_rec_data(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size) vwr_t * vwr = ( vwr_t * ) wth -> priv ; int bytes_written = 0 ; register int i register guint8 * s_ptr , * m_ptr ; gint16 octets , msdu_length ; guint8 m_type , flow_seq ; guint16 info ; gint16 rssi ; int f_tx ; int rate ; guint16 vc_id , flow_id , ht_len = 0 ; guint32 d_time , errors ; ext_rtap_fields er_fields ; s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); m_type = s_ptr [ vwr -> MTYPE_OFF ] & vwr -> MT_MASK; f_tx = ! ( s_ptr [ vwr -> MTYPE_OFF ] & vwr -> IS_RX ); octets = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); errors = pntohs ( & s_ptr [ vwr -> ERRORS_OFF ] ); info = pntohs ( & s_ptr [ vwr -> INFO_OFF ] ); rssi = ( s_ptr [ vwr -> RSSI_OFF ] & 0x80 ) ? ( - 1 * ( s_ptr [ vwr -> RSSI_OFF ] & 0x7f ) ) : s_ptr [ vwr -> RSSI_OFF ]; if ( m_type == vwr -> MT_OFDM )  rate = get_ofdm_rate ( rec ); static guint8 get_ofdm_rate(guint8 *plcp) switch ( plcp [ 0 ] & 0x0f )  return ( 6 * 2 ) ; return ( 9 * 2 ) ; return ( 12 * 2 ) ; return ( 18 * 2 ) ; return ( 24 * 2 ) ; return ( 36 * 2 ) ; return ( 48 * 2 ) ; return ( 54 * 2 ) ; return ( 0 ) ; if ( ( m_type == vwr -> MT_CCKL ) || ( m_type == vwr -> MT_CCKS ) )  rate = get_cck_rate ( rec ); static guint8 get_cck_rate(guint8 *plcp) switch ( plcp [ 0 ] )  return ( 1 * 2 ) ; return ( 2 * 2 ) ; return ( 11 ) ; return ( 11 * 2 ) ; return ( 0 ) ; rate = 1; m_ptr = & ( rec [ ( ( m_type == vwr -> MT_OFDM ) ? 4 : 6 ) ] ); octets -= ( m_type == vwr -> MT_OFDM ) ? 4 : 6; if ( octets > ( rec_size - ( int ) vwr -> STATS_LEN ) )  octets = ( rec_size - ( int ) vwr -> STATS_LEN ); msdu_length = octets; er_fields . it_len = EXT_RTAP_FIELDS_LEN; er_fields . flags = ( m_type == vwr -> MT_CCKS ) ? RADIOTAP_F_SHORTPRE : 0; er_fields . rate = rate; er_fields . chanflags = ( m_type == vwr -> MT_OFDM ) ? CHAN_OFDM : CHAN_CCK; er_fields . signal = f_tx ? 100 : ( gint8 ) rssi; er_fields . tx_power = f_tx ? ( ( gint8 ) rssi ) : 100; er_fields . vw_flags = 0; if ( f_tx )  er_fields . vw_flags |= RADIOTAP_VWF_TXF; if ( errors & vwr -> FCS_ERROR )  er_fields . vw_flags |= RADIOTAP_VWF_FCSERR; if ( ! f_tx && ( errors & vwr -> CRYPTO_ERR ) )  er_fields . vw_flags |= RADIOTAP_VWF_DCRERR; if ( ! f_tx && ( errors & vwr -> RETRY_ERR ) )  er_fields . vw_flags |= RADIOTAP_VWF_RETRERR; if ( info & vwr -> WEPTYPE )  er_fields . vw_flags |= RADIOTAP_VWF_IS_WEP; if ( info & vwr -> TKIPTYPE )  er_fields . vw_flags |= RADIOTAP_VWF_IS_TKIP; if ( info & vwr -> CCMPTYPE )  er_fields . vw_flags |= RADIOTAP_VWF_IS_CCMP; er_fields . vw_errors = ( guint32 ) errors; er_fields . vw_info = ( guint16 ) info; er_fields . vw_ht_length = ( guint16 ) ht_len; bytes_written += 2; bytes_written += 2; bytes_written += 2; memset ( & data_ptr [ bytes_written ] , 0 , 2 ); bytes_written += 2; bytes_written += 4; bytes_written += 2; bytes_written += 2; bytes_written += 4; bytes_written += 4; bytes_written += 8; bytes_written += 8; bytes_written += 4; memset ( & data_ptr [ bytes_written ] , 0 , 4 ); bytes_written += 4; bytes_written += 2; bytes_written += 2; bytes_written += 2; data_ptr [ bytes_written ] = er_fields . rate; bytes_written += 1; data_ptr [ bytes_written ] = er_fields . signal; bytes_written += 1; data_ptr [ bytes_written ] = er_fields . tx_power; bytes_written += 1; data_ptr [ bytes_written ] = 0; bytes_written += 1; bytes_written += 2; bytes_written += 2; bytes_written += 2; bytes_written += 4; if ( rec_size < ( ( int ) msdu_length + ( int ) vwr -> STATS_LEN ) )  memcpy ( & data_ptr [ bytes_written ] , m_ptr , octets ); memcpy ( & data_ptr [ bytes_written ] , m_ptr , octets - 4 ); 