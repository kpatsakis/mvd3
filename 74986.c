long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg) struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ); struct pipe_inode_info *get_pipe_info(struct file *file) return file -> f_op == & pipefifo_fops ? file -> private_data : NULL ; if ( ! pipe )  switch ( cmd )  unsigned int size , nr_pages ; size = round_pipe_size ( arg ); static inline unsigned int round_pipe_size(unsigned int size) unsigned long nr_pages ; nr_pages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT; return roundup_pow_of_two ( nr_pages ) << PAGE_SHIFT ; nr_pages = size >> PAGE_SHIFT; if ( ! nr_pages )  if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size )  ret = pipe_set_size ( pipe , nr_pages ); static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages) struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs )  bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ); if ( unlikely ( ! bufs ) )  if ( pipe -> nrbufs )  unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs; if ( tail < pipe -> buffers )  tail = 0; tail &= ( pipe -> buffers - 1 ); head = pipe -> nrbufs - tail; if ( head )  memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ); if ( tail )  memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ); pipe -> bufs = bufs; pipe -> buffers = nr_pages; 