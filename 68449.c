static void xhci_complete(USBPort *port, USBPacket *packet) XHCITransfer * xfer = container_of ( packet , XHCITransfer , packet ) ; if ( packet -> status == USB_RET_REMOVE_FROM_QUEUE )  xhci_kick_ep ( xfer -> xhci , xfer -> slotid , xfer -> epid , xfer -> streamid ); static void xhci_kick_ep(XHCIState *xhci, unsigned int unsigned int epid, unsigned int streamid) XHCIStreamContext * stctx ; XHCIEPContext * epctx ; XHCIRing * ring ; int length ; int i ; if ( ! xhci -> slots [ slotid - 1 ] . enabled )  epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ]; if ( ! epctx )  if ( ! xhci -> slots [ slotid - 1 ] . uport || ! xhci -> slots [ slotid - 1 ] . uport -> dev || ! xhci -> slots [ slotid - 1 ] . uport -> dev -> attached )  if ( epctx -> retry )  XHCITransfer * xfer = epctx -> retry ; if ( xfer -> timed_xfer )  if ( xfer -> running_retry )  xfer -> timed_xfer = 0; xfer -> running_retry = 1; if ( xfer -> iso_xfer )  if ( xhci_setup_packet ( xfer ) < 0 )  static int xhci_setup_packet(XHCITransfer *xfer) XHCIState * xhci = xfer -> xhci ; USBEndpoint * ep ; if ( xfer -> packet . ep )  ep = xhci_epid_to_usbep ( xhci , xfer -> slotid , xfer -> epid ); static USBEndpoint *xhci_epid_to_usbep(XHCIState unsigned int slotid, unsigned int epid) if ( ! xhci -> slots [ slotid - 1 ] . uport )  return NULL ; return usb_ep_get ( xhci -> slots [ slotid - 1 ] . uport -> dev , ( epid & 1 ) ? USB_TOKEN_IN : USB_TOKEN_OUT , epid >> 1 ) ; if ( ! ep )  return - 1 ; return 0 ; if ( xhci_setup_packet ( xfer ) < 0 )  static int xhci_setup_packet(XHCITransfer *xfer) XHCIState * xhci = xfer -> xhci ; USBEndpoint * ep ; if ( xfer -> packet . ep )  ep = xhci_epid_to_usbep ( xhci , xfer -> slotid , xfer -> epid ); if ( ! ep )  return - 1 ; return 0 ; if ( xfer -> packet . status == USB_RET_NAK )  epctx -> retry = NULL; if ( epctx -> state == EP_HALTED )  if ( epctx -> nr_pstreams )  stctx = xhci_find_stream ( epctx , streamid , & err ); static XHCIStreamContext *xhci_find_stream(XHCIEPContext unsigned int uint32_t *cc_error) XHCIStreamContext * sctx ; uint32_t ctx [ 2 ] , sct ; if ( epctx -> lsa )  if ( streamid >= epctx -> nr_pstreams )  return NULL ; sctx = epctx -> pstreams + streamid; if ( sctx -> sct == - 1 )  sct = ( ctx [ 0 ] >> 1 ) & 0x07; if ( epctx -> lsa && sct != 1 )  return NULL ; sctx -> sct = sct; return sctx ; if ( stctx == NULL )  ring = & stctx -> ring; ring = & epctx -> ring; streamid = 0; while ( 1 )  XHCITransfer * xfer = & epctx -> transfers [ epctx -> next_xfer ] ; if ( xfer -> running_async || xfer -> running_retry )  length = xhci_ring_chain_length ( xhci , ring ); static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring) XHCITRB trb ; int length = 0 ; bool ccs = ring -> ccs ; bool control_td_set = 0 ; while ( 1 )  TRBType type ; if ( ( trb . control & TRB_C ) != ccs )  return - length ; type = TRB_TYPE ( trb ); if ( type == TR_LINK )  if ( trb . control & TRB_LK_TC )  ccs = ! ccs; length += 1; if ( type == TR_SETUP )  control_td_set = 1; if ( type == TR_STATUS )  control_td_set = 0; if ( ! control_td_set && ! ( trb . control & TRB_TR_CH ) )  return length ; if ( length < 0 )  if ( length == 0 )  if ( xfer -> trbs && xfer -> trb_alloced < length )  xfer -> trb_count = 0; xfer -> trb_alloced = 0; xfer -> trbs = NULL; if ( ! xfer -> trbs )  xfer -> trbs = g_malloc ( sizeof ( XHCITRB ) * length ); xfer -> trb_alloced = length; xfer -> trb_count = length; for (i = 0; i < length; i++) assert ( xhci_ring_fetch ( xhci , ring , & xfer -> trbs [ i ] , NULL ) ); static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB dma_addr_t *addr) while ( 1 )  TRBType type ; trb -> addr = ring -> dequeue; trb -> ccs = ring -> ccs; if ( ( trb -> control & TRB_C ) != ring -> ccs )  return 0 ; type = TRB_TYPE ( * trb ); if ( type != TR_LINK )  return type ; ring -> dequeue = xhci_mask64 ( trb -> parameter ); static inline dma_addr_t xhci_mask64(uint64_t addr) if ( sizeof ( dma_addr_t ) == 4 )  return addr & 0xffffffff ; return addr ; if ( trb -> control & TRB_LK_TC )  ring -> ccs = ! ring -> ccs; xfer -> streamid = streamid; if ( epid == 1 )  if ( xhci_fire_ctl_transfer ( xhci , xfer ) >= 0 )  epctx -> next_xfer = ( epctx -> next_xfer + 1 ) % TD_QUEUE; if ( xhci_fire_transfer ( xhci , xfer , epctx ) >= 0 )  epctx -> next_xfer = ( epctx -> next_xfer + 1 ) % TD_QUEUE; if ( epctx -> state == EP_HALTED )  if ( xfer -> running_retry )  