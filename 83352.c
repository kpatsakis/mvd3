static void xhci_port_write(void *ptr, hwaddr uint64_t val, unsigned size) XHCIPort * port = ptr ; switch ( reg )  if ( val & PORTSC_WPR )  if ( val & PORTSC_PR )  xhci_port_reset ( port , false ); static void xhci_port_reset(XHCIPort *port, bool warm_reset) if ( ! xhci_port_have_device ( port ) )  static bool xhci_port_have_device(XHCIPort *port) if ( ! port -> uport -> dev || ! port -> uport -> dev -> attached )  return false ; if ( ! ( ( 1 << port -> uport -> dev -> speed ) & port -> speedmask ) )  return false ; return true ; switch ( port -> uport -> dev -> speed )  if ( warm_reset )  port -> portsc |= PORTSC_WRC; port -> portsc |= PORTSC_PED; port -> portsc &= ~PORTSC_PR; xhci_port_notify ( port , PORTSC_PRC ); static void xhci_port_notify(XHCIPort *port, uint32_t bits) if ( ( port -> portsc & bits ) == bits )  port -> portsc |= bits; if ( ! xhci_running ( port -> xhci ) )  xhci_event ( port -> xhci , & ev , 0 ); static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v) XHCIInterrupter * intr ; dma_addr_t erdp ; unsigned int dp_idx ; if ( v >= xhci -> numintrs )  intr = & xhci -> intr [ v ]; if ( intr -> er_full )  erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high ); if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )  dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE; assert ( dp_idx < intr -> er_size ); 