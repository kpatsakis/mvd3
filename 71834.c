static int get_scsi_requests(QEMUFile *f, void *pv, size_t size) SCSIDevice * s = pv ; int8_t sbyte ; while ( ( sbyte = qemu_get_sbyte ( f ) ) > 0 )  uint8_t buf [ SCSI_CMD_BUF_SIZE ] ; uint32_t tag ; uint32_t lun ; SCSIRequest * req ; req = scsi_req_new ( s , tag , lun , buf , NULL ); SCSIRequest *scsi_req_new(SCSIDevice *d, uint32_t tag, uint32_t uint8_t *buf, void *hba_private) SCSIBus * bus = DO_UPCAST ( SCSIBus , qbus , d -> qdev . parent_bus ) ; const SCSIReqOps * ops ; SCSIDeviceClass * sc = SCSI_DEVICE_GET_CLASS ( d ) ; SCSICommand cmd = . len = 0 int ret ; if ( ( d -> unit_attention . key == UNIT_ATTENTION || bus -> unit_attention . key == UNIT_ATTENTION ) && ( buf [ 0 ] != INQUIRY && buf [ 0 ] != REPORT_LUNS && buf [ 0 ] != GET_CONFIGURATION && buf [ 0 ] != GET_EVENT_STATUS_NOTIFICATION && ! ( buf [ 0 ] == REQUEST_SENSE && d -> sense_is_ua ) ) )  ops = & reqops_unit_attention; if ( lun != d -> lun || buf [ 0 ] == REPORT_LUNS || ( buf [ 0 ] == REQUEST_SENSE && d -> sense_len ) )  ops = & reqops_target_command; ops = NULL; if ( ops != NULL || ! sc -> parse_cdb )  ret = scsi_req_parse_cdb ( d , & cmd , buf ); int scsi_req_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf) int rc ; cmd -> lba = - 1; cmd -> len = scsi_cdb_length ( buf ); switch ( dev -> type )  rc = scsi_req_stream_xfer ( cmd , dev , buf ); rc = scsi_req_medium_changer_xfer ( cmd , dev , buf ); rc = scsi_req_xfer ( cmd , dev , buf ); if ( rc != 0 )  memcpy ( cmd -> buf , buf , cmd -> len ); scsi_cmd_xfer_mode ( cmd ); cmd -> lba = scsi_cmd_lba ( cmd ); 