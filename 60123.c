ram_addr_t qemu_ram_alloc(ram_addr_t size, MemoryRegion *mr) return qemu_ram_alloc_from_ptr ( size , NULL , mr ) ; ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void MemoryRegion *mr) RAMBlock * block , * new_block ; size = TARGET_PAGE_ALIGN ( size ); new_block = g_malloc0 ( sizeof ( * new_block ) ); new_block -> mr = mr; new_block -> offset = find_ram_offset ( size ); static ram_addr_t find_ram_offset(ram_addr_t size) RAMBlock * block , * next_block ; ram_addr_t offset = RAM_ADDR_MAX , mingap = RAM_ADDR_MAX ; if ( QTAILQ_EMPTY ( & ram_list . blocks ) )  return 0 ; ram_addr_t end , next = RAM_ADDR_MAX ; end = block -> offset + block -> length; if ( next_block -> offset >= end )  next = MIN ( next , next_block -> offset ); if ( next - end >= size && next - end < mingap )  offset = end; return offset ; if ( host )  if ( mem_path )  if ( xen_enabled ( ) )  if ( kvm_enabled ( ) )  new_block -> host = qemu_anon_ram_alloc ( size ); new_block -> length = size; ram_list . mru_block = NULL; ram_list . version ++; ram_list . phys_dirty = g_realloc ( ram_list . phys_dirty , last_ram_offset ( ) >> TARGET_PAGE_BITS ); ram_addr_t last_ram_offset(void) RAMBlock * block ; ram_addr_t last = 0 ; last = MAX ( last , block -> offset + block -> length ); return last ; memset ( ram_list . phys_dirty + ( new_block -> offset >> TARGET_PAGE_BITS ) , 0 , size >> TARGET_PAGE_BITS ); 