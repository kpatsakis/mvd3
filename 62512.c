static enum storeAtts(XML_Parser parser, const ENCODING const char *attStr, TAG_NAME BINDING **bindingsPtr) DTD * const dtd = _dtd ELEMENT_TYPE * elementType ; int nDefaultAtts ; const XML_Char * * appAtts ; int attIndex = 0 ; int i ; int n ; elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , tagNamePtr -> str , 0 ); if ( ! elementType )  const XML_Char * name = poolCopyString ( & dtd -> pool , tagNamePtr -> str ) ; if ( ! name )  elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , name , sizeof ( ELEMENT_TYPE ) ); if ( ! elementType )  if ( ns && ! setElementTypePrefix ( parser , elementType ) )  nDefaultAtts = elementType -> nDefaultAtts; n = XmlGetAttributes ( enc , attStr , attsSize , atts ); if ( n + nDefaultAtts > attsSize )  ATTRIBUTE * temp ; attsSize = n + nDefaultAtts + INIT_ATTS_SIZE; temp = ( ATTRIBUTE * ) REALLOC ( ( void * ) atts , attsSize * sizeof ( ATTRIBUTE ) ); if ( temp == NULL )  atts = temp; appAtts = ( const XML_Char * * ) atts; for (i = 0; i < n; i++) ATTRIBUTE_ID * attId = getAttributeId ( parser , enc , atts [ i ] . name , atts [ i ] . name + XmlNameLength ( enc , atts [ i ] . name ) ) ; if ( ! attId )  if ( ( attId -> name ) [ - 1 ] )  ( attId -> name ) [ - 1 ] = 1; appAtts [ attIndex ++ ] = attId -> name; if ( ! atts [ i ] . normalized )  enum XML_Error result ; XML_Bool isCdata = XML_TRUE ; if ( attId -> maybeTokenized )  int j ; for (j = 0; j < nDefaultAtts; j++) if ( attId == elementType -> defaultAtts [ j ] . id )  isCdata = elementType -> defaultAtts [ j ] . isCdata; result = storeAttributeValue ( parser , enc , isCdata , atts [ i ] . valuePtr , atts [ i ] . valueEnd , & tempPool ); if ( result )  appAtts [ attIndex ] = poolStart ( & tempPool ); appAtts [ attIndex ] = poolStoreString ( & tempPool , enc , atts [ i ] . valuePtr , atts [ i ] . valueEnd ); if ( appAtts [ attIndex ] == 0 )  if ( attId -> prefix )  if ( attId -> xmlns )  enum XML_Error result = addBinding ( parser , attId -> prefix , attId , appAtts [ attIndex ] , bindingsPtr ) ; if ( result )  attIndex ++; ( attId -> name ) [ - 1 ] = 2; attIndex ++; static ATTRIBUTE_ID getAttributeId(XML_Parser parser, const ENCODING const char *start, const char *end) DTD * const dtd = _dtd const XML_Char * name ; if ( ! poolAppendChar ( & dtd -> pool , XML_T ( '\0' ) ) )  name = poolStoreString ( & dtd -> pool , enc , start , end ); static XML_Char poolStoreString(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! poolAppend ( pool , enc , ptr , end ) )  if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  if ( pool -> blocks && pool -> start == pool -> blocks -> s )  BLOCK * tem ; int blockSize = ( int ) ( pool -> end - pool -> start ) ; if ( blockSize < INIT_BLOCK_SIZE )  blockSize = INIT_BLOCK_SIZE; blockSize *= 2; tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ); if ( ! tem )  tem -> size = blockSize; tem -> next = pool -> blocks; pool -> blocks = tem; if ( pool -> ptr != pool -> start )  memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) ); pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ); pool -> start = tem -> s; pool -> end = tem -> s + blockSize; 