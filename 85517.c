int sh_unsync(struct vcpu *v, mfn_t gmfn) struct page_info * pg ; pg = mfn_to_page ( gmfn ); if ( pg -> shadow_flags & ( ( SHF_page_type_mask & ~SHF_L1_ANY ) | SHF_out_of_sync ) || sh_page_has_multiple_shadows ( pg ) || is_pv_vcpu ( v ) || ! v -> domain -> arch . paging . shadow . oos_active )  oos_hash_add ( v , gmfn ); static void oos_hash_add(struct vcpu *v, mfn_t gmfn) void * gptr , * gsnpptr ; mfn_t * oos = v -> arch . paging . shadow . oos ; mfn_t * oos_snapshot = v -> arch . paging . shadow . oos_snapshot ; idx = mfn_x ( gmfn ) % SHADOW_OOS_PAGES; oidx = idx; if ( mfn_valid ( oos [ idx ] ) && ( mfn_x ( oos [ idx ] ) % SHADOW_OOS_PAGES ) == idx )  idx = ( idx + 1 ) % SHADOW_OOS_PAGES; oos [ idx ] = gmfn; gptr = map_domain_page ( oos [ oidx ] ); gsnpptr = map_domain_page ( oos_snapshot [ oidx ] ); memcpy ( gsnpptr , gptr , PAGE_SIZE ); unmap_domain_page ( gsnpptr ); 