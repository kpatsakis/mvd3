int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame int const AVPacket *avpkt) AVCodecInternal * avci = avctx -> internal ; int ret ; if ( ! avctx -> codec )  if ( avctx -> codec -> type != AVMEDIA_TYPE_VIDEO )  * got_picture_ptr = 0; if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( avctx -> coded_width , avctx -> coded_height , 0 , avctx ) )  if ( ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) || avpkt -> size || ( avctx -> active_thread_type & FF_THREAD_FRAME ) )  ret = apply_param_change ( avctx , & tmp ); static int apply_param_change(AVCodecContext *avctx, AVPacket *avpkt) int size = 0 , ret ; const uint8_t * data ; uint32_t flags ; int64_t val ; data = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PARAM_CHANGE , & size ); if ( ! data )  return 0 ; if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_PARAM_CHANGE ) )  return AVERROR ( EINVAL ) ; if ( size < 4 )  flags = bytestream_get_le32 ( & data ); size -= 4; if ( flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT )  if ( size < 4 )  val = bytestream_get_le32 ( & data ); if ( val <= 0 || val > INT_MAX )  return AVERROR_INVALIDDATA ; avctx -> channels = val; size -= 4; if ( flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT )  if ( size < 8 )  avctx -> channel_layout = bytestream_get_le64 ( & data ); size -= 8; if ( flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE )  if ( size < 4 )  val = bytestream_get_le32 ( & data ); if ( val <= 0 || val > INT_MAX )  return AVERROR_INVALIDDATA ; avctx -> sample_rate = val; size -= 4; if ( flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS )  if ( size < 8 )  avctx -> width = bytestream_get_le32 ( & data ); avctx -> height = bytestream_get_le32 ( & data ); ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ); int ff_set_dimensions(AVCodecContext *s, int width, int height) int ret = av_image_check_size ( width , height , 0 , s ) ; return ret ; if ( ret < 0 )  return ret ; return 0 ; return AVERROR_INVALIDDATA ; if ( ret < 0 )  if ( avctx -> err_recognition & AV_EF_EXPLODE )  avctx -> internal -> pkt = & tmp; if ( HAVE_THREADS && avctx -> active_thread_type & FF_THREAD_FRAME )  picture -> pkt_dts = avpkt -> dts; if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DR1 ) )  if ( ! picture -> sample_aspect_ratio . num )  picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio; if ( ! picture -> width )  picture -> width = avctx -> width; if ( ! picture -> height )  picture -> height = avctx -> height; if ( picture -> format == AV_PIX_FMT_NONE )  picture -> format = avctx -> pix_fmt; avctx -> internal -> pkt = NULL; if ( * got_picture_ptr )  if ( ! avctx -> refcounted_frames )  int err = unrefcount_frame ( avci , picture ) ; static int unrefcount_frame(AVCodecInternal *avci, AVFrame *frame) int ret ; ret = av_frame_copy_props ( frame , avci -> to_free ); if ( ret < 0 )  memcpy ( frame -> data , avci -> to_free -> data , sizeof ( frame -> data ) ); memcpy ( frame -> linesize , avci -> to_free -> linesize , sizeof ( frame -> linesize ) ); int size = planes * sizeof ( * frame -> extended_data ) ; if ( ! size )  av_frame_unref ( frame ); frame -> extended_data = av_malloc ( size ); if ( ! frame -> extended_data )  av_frame_unref ( frame ); memcpy ( frame -> extended_data , avci -> to_free -> extended_data , size ); frame -> extended_data = frame -> data; frame -> format = avci -> to_free -> format; frame -> width = avci -> to_free -> width; frame -> height = avci -> to_free -> height; frame -> channel_layout = avci -> to_free -> channel_layout; frame -> nb_samples = avci -> to_free -> nb_samples; av_frame_set_channels ( frame , av_frame_get_channels ( avci -> to_free ) ); 