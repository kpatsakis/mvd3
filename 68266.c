int attribute_align_arg ff_codec_open2_recursive(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options) ret = avcodec_open2 ( avctx , codec , options ); int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options) if ( avcodec_is_open ( avctx ) )  int avcodec_is_open(AVCodecContext *s) return ! ! s -> internal ; if ( ! codec && ! avctx -> codec )  if ( codec && avctx -> codec && codec != avctx -> codec )  if ( ! codec )  codec = avctx -> codec; if ( avctx -> extradata_size < 0 || avctx -> extradata_size >= FF_MAX_EXTRADATA_SIZE )  ret = ff_lock_avcodec ( avctx , codec ); int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec) if ( lockmgr_cb )  if ( ( * lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) )  return - 1 ; if ( avpriv_atomic_int_add_and_fetch ( & entangled_thread_counter , 1 ) != 1 && ! ( codec -> caps_internal & FF_CODEC_CAP_INIT_THREADSAFE ) )  return AVERROR ( EINVAL ) ; return 0 ; if ( ret < 0 )  avctx -> internal = av_mallocz ( sizeof ( AVCodecInternal ) ); if ( ! avctx -> internal )  avctx -> internal -> pool = av_mallocz ( sizeof ( * avctx -> internal -> pool ) ); if ( ! avctx -> internal -> pool )  avctx -> internal -> to_free = av_frame_alloc ( ); if ( ! avctx -> internal -> to_free )  if ( codec -> priv_data_size > 0 )  if ( ! avctx -> priv_data )  avctx -> priv_data = av_mallocz ( codec -> priv_data_size ); if ( ! avctx -> priv_data )  if ( codec -> priv_class )  * ( const AVClass * * ) avctx -> priv_data = codec -> priv_class; if ( codec -> priv_class && ( ret = av_opt_set_dict ( avctx -> priv_data , & tmp ) ) < 0 )  avctx -> priv_data = NULL; if ( ( ret = av_opt_set_dict ( avctx , & tmp ) ) < 0 )  if ( avctx -> codec_whitelist && av_match_list ( codec -> name , avctx -> codec_whitelist , ',' ) <= 0 )  if ( ! ( avctx -> coded_width && avctx -> coded_height && avctx -> width && avctx -> height && ( avctx -> codec_id == AV_CODEC_ID_H264 || avctx -> codec_id == AV_CODEC_ID_VP6F ) ) )  if ( avctx -> coded_width && avctx -> coded_height )  ret = ff_set_dimensions ( avctx , avctx -> coded_width , avctx -> coded_height ); int ff_set_dimensions(AVCodecContext *s, int width, int height) int ret = av_image_check_size ( width , height , 0 , s ) ; return ret ; if ( avctx -> width && avctx -> height )  ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ); int ff_set_dimensions(AVCodecContext *s, int width, int height) int ret = av_image_check_size ( width , height , 0 , s ) ; return ret ; if ( ret < 0 )  if ( avctx -> width > 0 && avctx -> height > 0 )  if ( av_image_check_sar ( avctx -> width , avctx -> height , avctx -> sample_aspect_ratio ) < 0 )  avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1 if ( avctx -> channels > FF_SANE_NB_CHANNELS )  avctx -> codec = codec; if ( ( avctx -> codec_type == AVMEDIA_TYPE_UNKNOWN || avctx -> codec_type == codec -> type ) && avctx -> codec_id == AV_CODEC_ID_NONE )  avctx -> codec_type = codec -> type; avctx -> codec_id = codec -> id; if ( avctx -> codec_id != codec -> id || ( avctx -> codec_type != codec -> type && avctx -> codec_type != AVMEDIA_TYPE_ATTACHMENT ) )  avctx -> frame_number = 0; avctx -> codec_descriptor = avcodec_descriptor_get ( avctx -> codec_id ); if ( ( avctx -> codec -> capabilities & AV_CODEC_CAP_EXPERIMENTAL ) && avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL )  if ( avctx -> codec_type == AVMEDIA_TYPE_AUDIO && ( ! avctx -> time_base . num || ! avctx -> time_base . den ) )  avctx -> time_base . num = 1; avctx -> time_base . den = avctx -> sample_rate; if ( CONFIG_FRAME_THREAD_ENCODER )  ret = ff_frame_thread_encoder_init ( avctx , options ? * options : NULL ); if ( ret < 0 )  if ( HAVE_THREADS && ! ( avctx -> internal -> frame_thread_encoder && ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  ret = ff_thread_init ( avctx ); int ff_thread_init(AVCodecContext *s) return - 1 ; if ( ret < 0 )  if ( ! HAVE_THREADS && ! ( codec -> capabilities & AV_CODEC_CAP_AUTO_THREADS ) )  avctx -> thread_count = 1; if ( avctx -> codec -> max_lowres < avctx -> lowres || avctx -> lowres < 0 )  if ( av_codec_is_encoder ( avctx -> codec ) )  int av_codec_is_encoder(const AVCodec *codec) return codec && ( codec -> encode_sub || codec -> encode2 ) ; int i ; avctx -> coded_frame = av_frame_alloc ( ); if ( ! avctx -> coded_frame )  if ( avctx -> codec -> sample_fmts )  for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) if ( avctx -> sample_fmt == avctx -> codec -> sample_fmts [ i ] )  if ( avctx -> channels == 1 && av_get_planar_sample_fmt ( avctx -> sample_fmt ) == av_get_planar_sample_fmt ( avctx -> codec -> sample_fmts [ i ] ) )  avctx -> sample_fmt = avctx -> codec -> sample_fmts [ i ]; if ( avctx -> codec -> sample_fmts [ i ] == AV_SAMPLE_FMT_NONE )  char buf [ 128 ] ; snprintf ( buf , sizeof ( buf ) , "%d" , avctx -> sample_fmt ); av_log ( avctx , AV_LOG_ERROR , "Specified sample format %s is invalid or not supported\n" , ( char * ) av_x_if_null ( av_get_sample_fmt_name ( avctx -> sample_fmt ) , buf ) ); 