static brcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device u8 key_idx, bool pairwise, const u8 struct key_params *params) struct brcmf_if * ifp = netdev_priv ( ndev ) ; if ( ! check_vif_up ( ifp -> vif ) )  static bool check_vif_up(struct brcmf_cfg80211_vif *vif) if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  return false ; return true ; if ( key_idx >= BRCMF_MAX_DEFAULT_KEYS )  if ( params -> key_len == 0 )  return brcmf_cfg80211_del_key ( wiphy , ndev , key_idx , pairwise , mac_addr ) ; static brcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device u8 key_idx, bool pairwise, const u8 *mac_addr) struct brcmf_if * ifp = netdev_priv ( ndev ) ; struct brcmf_wsec_key * key ; if ( ! check_vif_up ( ifp -> vif ) )  static bool check_vif_up(struct brcmf_cfg80211_vif *vif) if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  return false ; return true ; if ( key_idx >= BRCMF_MAX_DEFAULT_KEYS )  key = & ifp -> vif -> profile . key [ key_idx ]; if ( key -> algo == CRYPTO_ALGO_OFF )  memset ( key , 0 , sizeof ( * key ) ); key -> index = ( u32 ) key_idx; key -> flags = BRCMF_PRIMARY_KEY; err = send_key_to_dongle ( ifp , key ); static send_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key) convert_key_from_CPU ( key , & key_le ); static void convert_key_from_CPU(struct brcmf_wsec_key struct brcmf_wsec_key_le *key_le) key_le -> index = cpu_to_le32 ( key -> index ); key_le -> len = cpu_to_le32 ( key -> len ); key_le -> algo = cpu_to_le32 ( key -> algo ); key_le -> flags = cpu_to_le32 ( key -> flags ); key_le -> rxiv . hi = cpu_to_le32 ( key -> rxiv . hi ); key_le -> rxiv . lo = cpu_to_le16 ( key -> rxiv . lo ); key_le -> iv_initialized = cpu_to_le32 ( key -> iv_initialized ); memcpy ( key_le -> data , key -> data , sizeof ( key -> data ) ); memcpy ( key_le -> ea , key -> ea , sizeof ( key -> ea ) ); brcmf_netdev_wait_pend8021x ( ifp ); err = brcmf_fil_bsscfg_data_set ( ifp , "wsec_key" , & key_le , sizeof ( key_le ) ); if ( err )  brcmf_err ( "wsec_key error (%d)\n" , err ); return err ; return err ; 