static TRBCCode xhci_configure_slot(XHCIState *xhci, unsigned int uint64_t pictx, bool dc) dma_addr_t ictx , octx ; uint32_t ictl_ctx [ 2 ] ; uint32_t slot_ctx [ 4 ] ; uint32_t ep_ctx [ 5 ] ; int i ; TRBCCode res ; octx = xhci -> slots [ slotid - 1 ] . ctx; if ( dc )  if ( ( ictl_ctx [ 0 ] & 0x3 ) != 0x0 || ( ictl_ctx [ 1 ] & 0x3 ) != 0x1 )  if ( SLOT_STATE ( slot_ctx [ 3 ] ) < SLOT_ADDRESSED )  for (i = 2; i <= 31; i++) if ( ictl_ctx [ 1 ] & ( 1 << i ) )  res = xhci_enable_ep ( xhci , slotid , i , octx + ( 32 * i ) , ep_ctx ); if ( res != CC_SUCCESS )  res = xhci_alloc_device_streams ( xhci , slotid , ictl_ctx [ 1 ] ); static TRBCCode xhci_alloc_device_streams(XHCIState *xhci, unsigned int uint32_t epmask) XHCIEPContext * epctxs [ 30 ] ; USBEndpoint * eps [ 30 ] ; int i , r , nr_eps , req_nr_streams , dev_max_streams ; nr_eps = xhci_epmask_to_eps_with_streams ( xhci , slotid , epmask , epctxs , eps ); static int xhci_epmask_to_eps_with_streams(XHCIState unsigned int uint32_t XHCIEPContext USBEndpoint **eps) XHCISlot * slot ; XHCIEPContext * epctx ; USBEndpoint * ep ; int i , j ; slot = & xhci -> slots [ slotid - 1 ]; for (i = 2, j = 0; i <= 31; i++) if ( ! ( epmask & ( 1u << i ) ) )  epctx = slot -> eps [ i - 1 ]; ep = xhci_epid_to_usbep ( xhci , slotid , i ); static USBEndpoint *xhci_epid_to_usbep(XHCIState unsigned int slotid, unsigned int epid) if ( ! xhci -> slots [ slotid - 1 ] . uport )  return NULL ; return usb_ep_get ( xhci -> slots [ slotid - 1 ] . uport -> dev , ( epid & 1 ) ? USB_TOKEN_IN : USB_TOKEN_OUT , epid >> 1 ) ; if ( ! epctx || ! epctx -> nr_pstreams || ! ep )  if ( epctxs )  epctxs [ j ] = epctx; eps [ j ++ ] = ep; return j ; if ( nr_eps == 0 )  return CC_SUCCESS ; req_nr_streams = epctxs [ 0 ] -> nr_pstreams; dev_max_streams = eps [ 0 ] -> max_streams; for (i = 1; i < nr_eps; i++) if ( epctxs [ i ] -> nr_pstreams != req_nr_streams )  return CC_RESOURCE_ERROR ; if ( eps [ i ] -> max_streams != dev_max_streams )  return CC_RESOURCE_ERROR ; if ( req_nr_streams > dev_max_streams )  req_nr_streams = dev_max_streams; r = usb_device_alloc_streams ( eps [ 0 ] -> dev , eps , nr_eps , req_nr_streams ); if ( r != 0 )  return CC_RESOURCE_ERROR ; return CC_SUCCESS ; if ( res != CC_SUCCESS )  for (i = 2; i <= 31; i++) if ( ictl_ctx [ 1 ] & ( 1u << i ) )  xhci_disable_ep ( xhci , slotid , i ); static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int unsigned int epid) XHCISlot * slot ; XHCIEPContext * epctx ; slot = & xhci -> slots [ slotid - 1 ]; if ( ! slot -> eps [ epid - 1 ] )  epctx = slot -> eps [ epid - 1 ]; xhci_set_ep_state ( xhci , epctx , NULL , EP_DISABLED ); static void xhci_set_ep_state(XHCIState *xhci, XHCIEPContext XHCIStreamContext *sctx, uint32_t state) uint32_t ctx2 [ 2 ] ; if ( epctx -> nr_pstreams )  if ( sctx != NULL )  xhci_dma_read_u32s ( xhci , sctx -> pctx , ctx2 , sizeof ( ctx2 ) ); static inline void xhci_dma_read_u32s(XHCIState *xhci, dma_addr_t uint32_t *buf, size_t len) assert ( ( len % sizeof ( uint32_t ) ) == 0 ); 