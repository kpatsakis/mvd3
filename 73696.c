static int xc2028_set_params(struct dvb_frontend *fe) struct dtv_frontend_properties * c = & fe -> dtv_property_cache ; u32 delsys = c -> delivery_system ; u32 bw = c -> bandwidth_hz ; struct xc2028_data * priv = fe -> tuner_priv ; int rc ; unsigned int type = 0 ; u16 demod = 0 ; rc = check_device_status ( priv ); if ( rc < 0 )  switch ( delsys )  if ( bw <= 6000000 )  type |= QAM; switch ( priv -> ctrl . type )  type |= D2633; type |= D2620; if ( priv -> ctrl . demod == XC3028_FE_ZARLINK456 )  type |= D2633; type |= D2620; type |= ATSC | D2633; if ( bw <= 6000000 )  type |= DTV6; priv -> ctrl . vhfbw7 = 0; priv -> ctrl . uhfbw8 = 0; if ( bw <= 7000000 )  if ( c -> frequency < 470000000 )  priv -> ctrl . vhfbw7 = 1; priv -> ctrl . uhfbw8 = 0; type |= ( priv -> ctrl . vhfbw7 && priv -> ctrl . uhfbw8 ) ? DTV78 : DTV7; type |= F8MHZ; if ( c -> frequency < 470000000 )  priv -> ctrl . vhfbw7 = 0; priv -> ctrl . uhfbw8 = 1; type |= ( priv -> ctrl . vhfbw7 && priv -> ctrl . uhfbw8 ) ? DTV78 : DTV8; type |= F8MHZ; if ( priv -> ctrl . demod )  demod = priv -> ctrl . demod; if ( type == ATSC || priv -> firm_version < 0x0302 )  demod += 200; return generic_set_freq ( fe , c -> frequency , V4L2_TUNER_DIGITAL_TV , type , 0 , demod ) ; static int generic_set_freq(struct dvb_frontend *fe, u32 freq /* in HZ enum v4l2_tuner_type unsigned int v4l2_std_id u16 int_freq) if ( check_firmware ( fe , type , std , int_freq ) < 0 )  static int check_firmware(struct dvb_frontend *fe, unsigned int v4l2_std_id std, __u16 int_freq) struct xc2028_data * priv = fe -> tuner_priv ; struct firmware_properties new_fw ; int rc , retry_count = 0 ; u16 version , hwmodel ; v4l2_std_id std0 ; rc = check_device_status ( priv ); if ( rc < 0 )  if ( priv -> ctrl . mts && ! ( type & FM ) )  type |= MTS; new_fw . type = type; new_fw . id = std; new_fw . std_req = std; new_fw . scode_table = SCODE | priv -> ctrl . scode_table; new_fw . scode_nr = 0; new_fw . int_freq = int_freq; if ( ( priv -> state == XC2028_ACTIVE ) && ( ( ( BASE | new_fw . type ) & BASE_TYPES ) == ( priv -> cur_fw . type & BASE_TYPES ) ) )  memset ( & priv -> cur_fw , 0 , sizeof ( priv -> cur_fw ) ); rc = do_tuner_callback ( fe , XC2028_TUNER_RESET , 0 ); if ( rc < 0 )  std0 = 0; rc = load_firmware ( fe , BASE | new_fw . type , & std0 ); if ( rc < 0 )  rc = load_firmware ( fe , BASE | INIT1 | new_fw . type , & std0 ); if ( rc == - ENOENT )  rc = load_firmware ( fe , ( BASE | INIT1 | new_fw . type ) & ~F8MHZ , & std0 ); if ( rc < 0 && rc != - ENOENT )  if ( priv -> cur_fw . type == ( BASE | new_fw . type ) && priv -> cur_fw . std_req == std )  priv -> cur_fw . scode_table = 0; rc = load_firmware ( fe , new_fw . type , & new_fw . id ); if ( rc == - ENOENT )  rc = load_firmware ( fe , new_fw . type & ~F8MHZ , & new_fw . id ); if ( rc < 0 )  if ( xc2028_get_reg ( priv , 0x0004 , & version ) < 0 || xc2028_get_reg ( priv , 0x0008 , & hwmodel ) < 0 )  if ( priv -> ctrl . read_not_reliable )  if ( priv -> firm_version != ( ( version & 0xf0 ) << 4 | ( version & 0x0f ) ) )  if ( ! priv -> ctrl . read_not_reliable )  hwmodel = 3028; if ( priv -> hwmodel == 0 && ( hwmodel == 2028 || hwmodel == 3028 ) )  priv -> hwmodel = hwmodel; priv -> hwvers = version & 0xff00; if ( priv -> hwmodel == 0 || priv -> hwmodel != hwmodel || priv -> hwvers != ( version & 0xff00 ) )  priv -> cur_fw = new_fw; priv -> cur_fw . type |= BASE; priv -> state = XC2028_ACTIVE; priv -> state = XC2028_NO_FIRMWARE; if ( retry_count < 8 )  retry_count ++; static int load_firmware(struct dvb_frontend *fe, unsigned int v4l2_std_id *id) struct xc2028_data * priv = fe -> tuner_priv ; int pos , rc ; unsigned char * p , * endp , buf [ MAX_XFER_SIZE ] ; if ( priv -> ctrl . max_len > sizeof ( buf ) )  priv -> ctrl . max_len = sizeof ( buf ); pos = seek_firmware ( fe , type , id ); if ( pos < 0 )  p = priv -> firm [ pos ] . ptr; endp = p + priv -> firm [ pos ] . size; while ( p < endp )  __u16 size ; if ( p + sizeof ( size ) > endp )  size = le16_to_cpu ( * ( __le16 * ) p ); p += sizeof ( size ); if ( size == 0xffff )  if ( ! size )  rc = do_tuner_callback ( fe , XC2028_TUNER_RESET , 0 ); if ( rc < 0 )  if ( size >= 0xff00 )  switch ( size )  rc = do_tuner_callback ( fe , XC2028_RESET_CLK , 0 ); if ( rc < 0 )  if ( size & 0x8000 )  if ( size + p > endp )  buf [ 0 ] = * p; p ++; size --; while ( size > 0 )  int len = ( size < priv -> ctrl . max_len - 1 ) ? size : priv -> ctrl . max_len - 1 ; memcpy ( buf + 1 , p , len ); rc = i2c_send ( priv , buf , len + 1 ); if ( rc < 0 )  tuner_err ( "%d returned from send\n" , rc ); p += len; size -= len; rc = do_tuner_callback ( fe , XC2028_I2C_FLUSH , 0 ); if ( ( rc < 0 ) && ( rc != - EINVAL ) )  tuner_err ( "error executing flush: %d\n" , rc ); return rc ; 