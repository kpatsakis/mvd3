 PointerType::ContentsSetter(JSContext* cx, JS::CallArgs args) RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ; RootedObject baseType ( cx , GetBaseType ( CData :: GetCType ( obj ) ) ) ;  CData::GetCType(JSObject* dataObj) jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ; JSObject * typeObj = slot . toObjectOrNull ( ) ; return typeObj ; if ( ! CType :: IsSizeDefined ( baseType ) )   CType::IsSizeDefined(JSObject* obj) jsval size = JS_GetReservedSlot ( obj , SLOT_SIZE ) ; return ! size . isUndefined ( ) ; void * data = * static_cast < void * * > CData :: GetData ( obj )  CData::GetData(JSObject* dataObj) void * * buffer = static_cast < void * * > slot . toPrivate ( ) return * buffer ; if ( data == nullptr )  return ImplicitConvert ( cx , args . get ( 0 ) , baseType , data , false , nullptr ) ; static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  sourceData = valObj; sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; if ( ! p )  if ( CType :: TypesEqual ( sourceType , targetType ) )  memmove ( buffer , p -> cargs , p -> cargs_size ); 