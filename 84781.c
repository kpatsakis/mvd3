static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event) struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmx -> rmode . vm86_active = 0; vmx -> soft_vnmi_blocked = 0; vmx -> vcpu . arch . regs [ VCPU_REGS_RDX ] = get_rdx_init_val ( ); if ( vmx_vm_has_apicv ( vcpu -> kvm ) )  static int vmx_vm_has_apicv(struct kvm *kvm) return enable_apicv && irqchip_in_kernel ( kvm ) ; memset ( & vmx -> pi_desc , 0 , sizeof ( struct pi_desc ) ); if ( vmx -> vpid != 0 )  vmcs_write16 ( VIRTUAL_PROCESSOR_ID , vmx -> vpid ); static void vmcs_write16(unsigned long field, u16 value) vmcs_writel ( field , value ); static void vmcs_writel(unsigned long field, unsigned long value) asm volatile ( __ex ( ASM_VMX_VMWRITE_RAX_RDX ) "; setna : "=q" ( error ) : "a" ( value ) , "d" ( field ) : "cc" ) vmwrite_error ( field , value ); static noinline void vmwrite_error(unsigned long field, unsigned long value) printk ( KERN_ERR "vmwrite error: reg %lx value %lx (err %d)\n" field , value , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) static __always_inline u32 vmcs_read32(unsigned long field) return vmcs_readl ( field ) ; static __always_inline unsigned long vmcs_readl(unsigned long field) asm volatile ( __ex_clear ( ASM_VMX_VMREAD_RDX_RAX , "%0" : "=a" ( value ) : "d" ( field ) : "cc" ) vmx -> vcpu . arch . cr0 = cr0; vpid_sync_context ( vmx ); static inline void vpid_sync_context(struct vcpu_vmx *vmx) vpid_sync_vcpu_single ( vmx ); static inline void vpid_sync_vcpu_single(struct vcpu_vmx *vmx) if ( vmx -> vpid == 0 )  __invvpid ( VMX_VPID_EXTENT_SINGLE_CONTEXT , vmx -> vpid , 0 ); static inline void __invvpid(int ext, u16 vpid, gva_t gva) struct { u64 vpid : 16 ; u64 rsvd : 48 ; u64 gva ; } operand = { vpid , 0 , gva } ; "; ja 1f ; ud2 ; : : "a" ( & operand ) , "c" ( ext ) : "cc" , "memory" ) 