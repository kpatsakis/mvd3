static long fuse_file_ioctl(struct file *file, unsigned int unsigned long arg) return fuse_ioctl_common ( file , cmd , arg , 0 ) ; long fuse_ioctl_common(struct file *file, unsigned int unsigned long arg, unsigned int flags) struct inode * inode = file_inode ( file ) ; struct fuse_conn * fc = get_fuse_conn ( inode ) ; if ( ! fuse_allow_current_process ( fc ) )  if ( is_bad_inode ( inode ) )  return fuse_do_ioctl ( file , cmd , arg , flags ) ; long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long unsigned int flags) struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg . fh = ff -> fh . cmd = cmd . arg = arg . flags = flags struct fuse_ioctl_out outarg ; struct page * * pages = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; inarg . flags |= FUSE_IOCTL_32BIT; err = - ENOMEM; pages = kcalloc ( FUSE_MAX_PAGES_PER_REQ , sizeof ( pages [ 0 ] ) , GFP_KERNEL ); iov_page = ( struct iovec * ) __get_free_page ( GFP_KERNEL ); if ( ! pages || ! iov_page )  if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )  struct iovec * iov = iov_page ; iov -> iov_base = ( void __user * ) arg; iov -> iov_len = _IOC_SIZE ( cmd ); if ( _IOC_DIR ( cmd ) & _IOC_WRITE )  in_iov = iov; in_iovs = 1; if ( _IOC_DIR ( cmd ) & _IOC_READ )  out_iov = iov; out_iovs = 1; inarg . in_size = in_size = iov_length ( in_iov , in_iovs ); inarg . out_size = out_size = iov_length ( out_iov , out_iovs ); out_size = max_t ( size_t , out_size , PAGE_SIZE ); max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ); err = - ENOMEM; if ( max_pages > FUSE_MAX_PAGES_PER_REQ )  while ( num_pages < max_pages )  pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ); if ( ! pages [ num_pages ] )  num_pages ++; req = fuse_get_req ( fc , num_pages ); if ( IS_ERR ( req ) )  memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ); req -> num_pages = num_pages; fuse_page_descs_length_init ( req , 0 , req -> num_pages ); req -> in . h . opcode = FUSE_IOCTL; req -> in . h . nodeid = ff -> nodeid; req -> in . numargs = 1; req -> in . args [ 0 ] . size = sizeof ( inarg ); req -> in . args [ 0 ] . value = & inarg; if ( in_size )  req -> in . numargs ++; req -> in . args [ 1 ] . size = in_size; req -> in . argpages = 1; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ); if ( err )  req -> out . numargs = 2; req -> out . args [ 0 ] . size = sizeof ( outarg ); req -> out . args [ 0 ] . value = & outarg; req -> out . args [ 1 ] . size = out_size; req -> out . argpages = 1; req -> out . argvar = 1; fuse_request_send ( fc , req ); err = req -> out . h . error; transferred = req -> out . args [ 1 ] . size; fuse_put_request ( fc , req ); if ( err )  if ( outarg . flags & FUSE_IOCTL_RETRY )  void * vaddr ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )  in_iovs = outarg . in_iovs; out_iovs = outarg . out_iovs; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV )  vaddr = kmap_atomic ( pages [ 0 ] ); err = fuse_copy_ioctl_iovec ( fc , iov_page , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ); if ( err )  in_iov = iov_page; out_iov = in_iov + in_iovs; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ); if ( err )  err = fuse_verify_ioctl_iov ( out_iov , out_iovs ); if ( err )  if ( transferred > inarg . out_size )  err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ); return err ? err : outarg . result ; 