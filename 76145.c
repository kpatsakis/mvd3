static void fdctrl_start_transfer(FDCtrl *fdctrl, int direction) FDrive * cur_drv ; uint8_t kh , kt , ks ; cur_drv = get_cur_drv ( fdctrl ); static FDrive *get_cur_drv(FDCtrl *fdctrl) switch ( fdctrl -> cur_drv )  return drv0 ( fdctrl ) ; static inline FDrive *drv0(FDCtrl *fdctrl) return & fdctrl -> drives [ ( fdctrl -> tdr & FD_TDR_BOOTSEL ) >> 2 ] ; return drv1 ( fdctrl ) ; static inline FDrive *drv1(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 1 << 2 ) )  return & fdctrl -> drives [ 1 ] ; return & fdctrl -> drives [ 0 ] ; return drv2 ( fdctrl ) ; static inline FDrive *drv2(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 2 << 2 ) )  return & fdctrl -> drives [ 2 ] ; return & fdctrl -> drives [ 1 ] ; return drv3 ( fdctrl ) ; static inline FDrive *drv3(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 3 << 2 ) )  return & fdctrl -> drives [ 3 ] ; return & fdctrl -> drives [ 2 ] ; return NULL ; kt = fdctrl -> fifo [ 2 ]; kh = fdctrl -> fifo [ 3 ]; ks = fdctrl -> fifo [ 4 ]; switch ( fd_seek ( cur_drv , kh , kt , ks , fdctrl -> config & FD_CONFIG_EIS ) )  static int fd_seek(FDrive *drv, uint8_t head, uint8_t track, uint8_t int enable_seek) uint32_t sector ; int ret ; if ( track > drv -> max_track || ( head != 0 && ( drv -> flags & FDISK_DBL_SIDES ) == 0 ) )  return 2 ; if ( sect > drv -> last_sect )  return 3 ; sector = fd_sector_calc ( head , track , sect , drv -> last_sect , NUM_SIDES ( drv ) ); static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; ret = 0; if ( sector != fd_sector ( drv ) )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; if ( ! enable_seek )  return 4 ; drv -> head = head; if ( drv -> track != track )  if ( drv -> blk != NULL && blk_is_inserted ( drv -> blk ) )  drv -> media_changed = 0; ret = 1; drv -> track = track; drv -> sect = sect; if ( drv -> blk == NULL || ! blk_is_inserted ( drv -> blk ) )  ret = 2; return ret ; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> status0 |= FD_SR0_SEEK; if ( fdctrl -> check_media_rate && ( fdctrl -> dsr & FD_DSR_DRATEMASK ) != cur_drv -> media_rate )  fdctrl -> data_dir = direction; fdctrl -> data_pos = 0; if ( fdctrl -> fifo [ 0 ] & 0x80 )  fdctrl -> data_state |= FD_STATE_MULTI; fdctrl -> data_state &= ~FD_STATE_MULTI; if ( fdctrl -> fifo [ 5 ] == 0 )  fdctrl -> data_len = fdctrl -> fifo [ 8 ]; int tmp ; fdctrl -> data_len = 128 << ( fdctrl -> fifo [ 5 ] > 7 ? 7 : fdctrl -> fifo [ 5 ] ); tmp = ( fdctrl -> fifo [ 6 ] - ks + 1 ); if ( fdctrl -> fifo [ 0 ] & 0x80 )  tmp += fdctrl -> fifo [ 6 ]; fdctrl -> data_len *= tmp; fdctrl -> eot = fdctrl -> fifo [ 6 ]; if ( fdctrl -> dor & FD_DOR_DMAEN )  int dma_mode ; dma_mode = DMA_get_channel_mode ( fdctrl -> dma_chann ); dma_mode = ( dma_mode >> 2 ) & 3; if ( ( ( direction == FD_DIR_SCANE || direction == FD_DIR_SCANL || direction == FD_DIR_SCANH ) && dma_mode == 0 ) || ( direction == FD_DIR_WRITE && dma_mode == 2 ) || ( direction == FD_DIR_READ && dma_mode == 1 ) || ( direction == FD_DIR_VERIFY ) )  fdctrl -> msr &= ~FD_MSR_RQM; if ( direction != FD_DIR_VERIFY )  fdctrl_transfer_handler ( fdctrl , fdctrl -> dma_chann , 0 , fdctrl -> data_len ); static int fdctrl_transfer_handler (void *opaque, int int dma_pos, int dma_len) FDCtrl * fdctrl ; FDrive * cur_drv ; int len , start_pos , rel_pos ; fdctrl = opaque; if ( fdctrl -> msr & FD_MSR_RQM )  cur_drv = get_cur_drv ( fdctrl ); static FDrive *get_cur_drv(FDCtrl *fdctrl) switch ( fdctrl -> cur_drv )  return drv0 ( fdctrl ) ; return drv1 ( fdctrl ) ; return drv2 ( fdctrl ) ; return drv3 ( fdctrl ) ; return NULL ; if ( dma_len > fdctrl -> data_len )  dma_len = fdctrl -> data_len; if ( cur_drv -> blk == NULL )  rel_pos = fdctrl -> data_pos % FD_SECTOR_LEN; for (start_pos = fdctrl->data_pos; fdctrl->data_pos < dma_len;) len = dma_len - fdctrl -> data_pos; if ( len + rel_pos > FD_SECTOR_LEN )  len = FD_SECTOR_LEN - rel_pos; if ( fdctrl -> data_dir != FD_DIR_WRITE || len < FD_SECTOR_LEN || rel_pos != 0 )  if ( blk_read ( cur_drv -> blk , fd_sector ( cur_drv ) , fdctrl -> fifo , 1 ) < 0 )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; memset ( fdctrl -> fifo , 0 , FD_SECTOR_LEN ); switch ( fdctrl -> data_dir )  if ( cur_drv -> ro )  if ( blk_write ( cur_drv -> blk , fd_sector ( cur_drv ) , fdctrl -> fifo , 1 ) < 0 )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; uint8_t tmpbuf [ FD_SECTOR_LEN ] ; int ret ; ret = memcmp ( tmpbuf , fdctrl -> fifo + rel_pos , len ); if ( ret == 0 )  if ( ( ret < 0 && fdctrl -> data_dir == FD_DIR_SCANL ) || ( ret > 0 && fdctrl -> data_dir == FD_DIR_SCANH ) )  fdctrl -> data_pos += len; rel_pos = fdctrl -> data_pos % FD_SECTOR_LEN; if ( rel_pos == 0 )  if ( ! fdctrl_seek_to_next_sect ( fdctrl , cur_drv ) )  static int fdctrl_seek_to_next_sect(FDCtrl *fdctrl, FDrive *cur_drv) FLOPPY_DPRINTF ( "seek to next sector (%d %02x %02x => %d)\n" , cur_drv -> head , cur_drv -> track , cur_drv -> sect , fd_sector ( cur_drv ) ); static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; uint8_t new_head = cur_drv -> head ; uint8_t new_track = cur_drv -> track ; uint8_t new_sect = cur_drv -> sect ; if ( new_sect >= cur_drv -> last_sect || new_sect == fdctrl -> eot )  if ( FD_MULTI_TRACK ( fdctrl -> data_state ) )  if ( new_head == 0 && ( cur_drv -> flags & FDISK_DBL_SIDES ) != 0 )  new_track ++; fdctrl -> status0 |= FD_SR0_SEEK; if ( ( cur_drv -> flags & FDISK_DBL_SIDES ) == 0 )  fdctrl -> status0 |= FD_SR0_SEEK; new_track ++; FLOPPY_DPRINTF ( "seek to next track (%d %02x %02x => %d)\n" , new_head , new_track , new_sect , fd_sector ( cur_drv ) ); static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; new_sect ++; fd_seek ( cur_drv , new_head , new_track , new_sect , 1 ); static int fd_seek(FDrive *drv, uint8_t head, uint8_t track, uint8_t int enable_seek) if ( track > drv -> max_track || ( head != 0 && ( drv -> flags & FDISK_DBL_SIDES ) == 0 ) )  FLOPPY_DPRINTF ( "try to read %d %02x %02x (max=%d %d %02x %02x)\n" , head , track , sect , 1 , ( drv -> flags & FDISK_DBL_SIDES ) == 0 ? 0 : 1 , drv -> max_track , drv -> last_sect ); if ( sect > drv -> last_sect )  FLOPPY_DPRINTF ( "try to read %d %02x %02x (max=%d %d %02x %02x)\n" , head , track , sect , 1 , ( drv -> flags & FDISK_DBL_SIDES ) == 0 ? 0 : 1 , drv -> max_track , drv -> last_sect ); sector = fd_sector_calc ( head , track , sect , drv -> last_sect , NUM_SIDES ( drv ) ); if ( sector != fd_sector ( drv ) )  if ( ! enable_seek )  FLOPPY_DPRINTF ( "error: no implicit seek %d %02x " (max=%d %02x %02x)\n" head , track , sect , 1 , drv -> max_track drv -> last_sect ) drv -> head = head; if ( drv -> track != track )  if ( drv -> blk != NULL && blk_is_inserted ( drv -> blk ) )  drv -> media_changed = 0; drv -> track = track; drv -> sect = sect; if ( drv -> blk == NULL || ! blk_is_inserted ( drv -> blk ) )  