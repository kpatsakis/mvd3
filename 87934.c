int attribute_align_arg avcodec_encode_video(AVCodecContext *avctx, uint8_t *buf, int const AVFrame *pict) AVPacket pkt ; if ( buf_size < AV_INPUT_BUFFER_MIN_SIZE )  pkt . data = buf; pkt . size = buf_size; ret = avcodec_encode_video2 ( avctx , & pkt , pict , & got_packet ); int attribute_align_arg avcodec_encode_video2(AVCodecContext AVPacket const AVFrame int *got_packet_ptr) AVPacket user_pkt = * avpkt ; if ( CONFIG_FRAME_THREAD_ENCODER && avctx -> internal -> frame_thread_encoder && ( avctx -> active_thread_type & FF_THREAD_FRAME ) )  if ( ( avctx -> flags & AV_CODEC_FLAG_PASS1 ) && avctx -> stats_out )  avctx -> stats_out [ 0 ] = '\0'; if ( ! ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) && ! frame )  if ( av_image_check_size ( avctx -> width , avctx -> height , 0 , avctx ) )  if ( avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer )  if ( user_pkt . data )  if ( user_pkt . size >= avpkt -> size )  memcpy ( user_pkt . data , avpkt -> data , avpkt -> size ); avpkt -> buf = user_pkt . buf; avpkt -> data = user_pkt . data; avpkt -> destruct = user_pkt . destruct; avpkt -> size = 0; if ( needs_realloc && avpkt -> data )  ret = av_buffer_realloc ( & avpkt -> buf , avpkt -> size + AV_INPUT_BUFFER_PADDING_SIZE ); if ( ret >= 0 )  avpkt -> data = avpkt -> buf -> data; if ( ret < 0 || ! * got_packet_ptr )  av_free_packet ( avpkt ); return ret ; 