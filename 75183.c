static int unix_stream_recvmsg(struct socket *sock, struct msghdr size_t size, int flags) struct unix_stream_read_state state . recv_actor = unix_stream_read_actor . socket = sock . msg = msg . size = size . flags = flags return unix_stream_read_generic ( & state ) ; static int unix_stream_read_generic(struct unix_stream_read_state *state) struct scm_cookie scm ; struct socket * sock = state -> socket ; struct sock * sk = sock -> sk ; int flags = state -> flags ; if ( sk -> sk_state != TCP_ESTABLISHED )  if ( flags & MSG_OOB )  memset ( & scm , 0 , sizeof ( scm ) ); if ( ! unix_skb_scm_eq ( skb , & scm ) )  static bool unix_skb_scm_eq(struct sk_buff struct scm_cookie *scm) const struct unix_skb_parms * u = & UNIXCB ( skb ) ; return u -> pid == scm -> pid && uid_eq ( u -> uid , scm -> creds . uid ) && gid_eq ( u -> gid , scm -> creds . gid ) && unix_secdata_eq ( scm , skb ) ; static inline bool unix_secdata_eq(struct scm_cookie *scm, struct sk_buff *skb) return ( scm -> secid == UNIXCB ( skb ) . secid ) ; scm_set_cred ( & scm , UNIXCB ( skb ) . pid , UNIXCB ( skb ) . uid , UNIXCB ( skb ) . gid ); unix_set_secdata ( & scm , skb ); static inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb) scm -> secid = UNIXCB ( skb ) . secid; unix_detach_fds ( & scm , skb ); static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb) scm -> fp = UNIXCB ( skb ) . fp; UNIXCB ( skb ) . fp = NULL; for (i = scm->fp->count-1; i >= 0; i--) unix_notinflight ( scm -> fp -> fp [ i ] ); if ( scm . fp )  scm . fp = scm_fp_dup ( UNIXCB ( skb ) . fp ); scm_recv ( sock , state -> msg , & scm , flags ); scm_destroy ( & scm ); 