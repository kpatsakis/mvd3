int cpu_memory_rw_debug(CPUState *cpu, target_ulong uint8_t *buf, int len, int is_write) int l ; hwaddr phys_addr ; target_ulong page ; while ( len > 0 )  page = addr & TARGET_PAGE_MASK; phys_addr = cpu_get_phys_page_debug ( cpu , page ); if ( phys_addr == - 1 )  l = ( page + TARGET_PAGE_SIZE ) - addr; if ( l > len )  l = len; phys_addr += ( addr & ~TARGET_PAGE_MASK ); if ( is_write )  cpu_physical_memory_write_rom ( phys_addr , buf , l ); len -= l; buf += l; addr += l; void cpu_physical_memory_write_rom(hwaddr const uint8_t *buf, int len) hwaddr l ; uint8_t * ptr ; hwaddr addr1 ; MemoryRegion * mr ; while ( len > 0 )  l = len; mr = address_space_translate ( & address_space_memory , addr , & addr1 , & l , true ); MemoryRegion *address_space_translate(AddressSpace *as, hwaddr hwaddr *xlat, hwaddr bool is_write) IOMMUTLBEntry iotlb ; MemoryRegionSection * section ; MemoryRegion * mr ; section = address_space_translate_internal ( as -> dispatch , addr , & addr , plen , true ); static MemoryRegionSection address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr hwaddr *plen, bool resolve_subpage) MemoryRegionSection * section ; section = address_space_lookup_region ( d , addr , resolve_subpage ); static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch hwaddr bool resolve_subpage) MemoryRegionSection * section ; subpage_t * subpage ; section = phys_page_find ( d -> phys_map , addr >> TARGET_PAGE_BITS , d -> nodes , d -> sections ); static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr Node *nodes, MemoryRegionSection *sections) PhysPageEntry * p ; int i ; for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) if ( lp . ptr == PHYS_MAP_NODE_NIL )  return & sections [ PHYS_SECTION_UNASSIGNED ] ; p = nodes [ lp . ptr ]; lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ]; return & sections [ lp . ptr ] ; if ( resolve_subpage && section -> mr -> subpage )  subpage = container_of ( section -> mr , subpage_t , iomem ); section = & d -> sections [ subpage -> sub_section [ SUBPAGE_IDX ( addr ) ] ]; return section ; return section ; mr = section -> mr; if ( ! mr -> iommu_ops )  iotlb = mr -> iommu_ops -> translate ( mr , addr ); addr = ( ( iotlb . translated_addr & ~iotlb . addr_mask ) | ( addr & iotlb . addr_mask ) ); if ( ! ( iotlb . perm & ( 1 << is_write ) ) )  mr = & io_mem_unassigned; as = iotlb . target_as; return mr ; if ( ! ( memory_region_is_ram ( mr ) || memory_region_is_romd ( mr ) ) )  addr1 += memory_region_get_ram_addr ( mr ); ptr = qemu_get_ram_ptr ( addr1 ); void *qemu_get_ram_ptr(ram_addr_t addr) RAMBlock * block = qemu_get_ram_block ( addr ) ; static RAMBlock *qemu_get_ram_block(ram_addr_t addr) RAMBlock * block ; block = ram_list . mru_block; return block ; if ( xen_enabled ( ) )  if ( block -> offset == 0 )  return xen_map_cache ( addr , 0 , 0 ) ; if ( block -> host == NULL )  block -> host = xen_map_cache ( block -> offset , block -> length , 1 ); return block -> host + ( addr - block -> offset ) ; memcpy ( ptr , buf , l ); len -= l; buf += l; addr += l; 